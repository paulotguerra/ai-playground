<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bingo Pro</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <!-- Custom Styles -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap');

        /* Custom animation for loading spinner */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .animate-spin-slow {
            animation: spin 2s linear infinite;
        }

        /* Custom styles for winner banner */
        .winner-banner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
            background-color: rgba(255, 215, 0, 0.9);
            color: #333;
            padding: 8px 16px;
            font-weight: 900;
            font-size: 1.8rem;
            border-radius: 8px;
            text-transform: uppercase;
            z-index: 10;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            pointer-events: none;
        }

        /* Styling for the card grid numbers */
        .bingo-card-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
        }
        .bingo-card-cell {
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .bingo-card-cell.marked {
            background-color: #3b82f6; /* blue-500 */
            color: white;
            font-weight: 700;
        }
        .bingo-card-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: white;
            border-radius: 4px;
        }
        .bingo-card-header .letter {
            font-size: 1.25rem;
        }
        .bingo-card-header .range {
            font-size: 0.7rem;
            opacity: 0.9;
        }
        
        /* Modal styles */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 40;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background-color: white;
            padding: 24px;
            border-radius: 12px;
            max-width: 95vw;
            width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }
    </style>
</head>
<body class="text-gray-800">
    
    <!-- Notification Container -->
    <div id="notification-container" class="fixed top-0 left-0 right-0 z-50 p-4 pointer-events-none flex justify-center"></div>

    <div id="app" class="container mx-auto p-4 max-w-7xl pb-24">
        <!-- Header -->
        <header class="bg-white p-6 rounded-xl shadow-md mb-6">
            <div class="flex items-center space-x-4">
                <div class="bg-blue-500 text-white w-16 h-16 rounded-full flex items-center justify-center text-4xl font-bold shadow-inner">
                    B
                </div>
                <div>
                    <h1 class="text-4xl font-bold text-gray-800">
                        Bingo Pro<sup class="text-sm font-semibold bg-blue-100 text-blue-800 px-2 py-0.5 rounded-md -top-5 relative ml-1">beta</sup>
                    </h1>
                    <p class="text-gray-500">O seu gestor de cartelas de bingo offline.</p>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Left Column -->
            <div class="lg:col-span-1 flex flex-col gap-6">
                <!-- Sorteio Section -->
                <div class="bg-white p-6 rounded-xl shadow-md">
                    <h2 class="text-2xl font-bold mb-4">Sorteio</h2>
                    <form id="draw-form" class="flex items-center gap-2 mb-4">
                        <input type="number" id="drawn-number-input" placeholder="Nº Sorteado" min="1" max="75" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition">
                        <button type="submit" class="bg-blue-500 text-white font-semibold py-3 px-5 rounded-lg hover:bg-blue-600 transition shadow">Adicionar</button>
                    </form>
                    
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-lg font-semibold">Números sorteados (<span id="drawn-count">0</span>)</h3>
                        <div class="flex gap-2">
                            <button id="sort-drawn-btn" class="text-sm text-blue-600 hover:text-blue-800 font-medium flex items-center gap-1">
                                <i class="fa-solid fa-arrow-up-wide-short"></i>
                                <span id="sort-order-text">Crescente</span>
                            </button>
                            <button id="clear-drawn-btn" class="bg-red-500 text-white font-semibold py-1 px-3 rounded-lg hover:bg-red-600 transition text-sm shadow">Limpar</button>
                        </div>
                    </div>

                    <div id="drawn-numbers-list" class="flex flex-wrap justify-start gap-2 bg-gray-100 p-3 rounded-lg min-h-[50px]">
                        <!-- Drawn numbers will be injected here -->
                    </div>
                </div>

                <!-- Card Controls Section -->
                <div class="bg-white p-6 rounded-xl shadow-md">
                    <h2 class="text-2xl font-bold mb-4">Cartelas</h2>
                    <div class="grid grid-cols-2 gap-3">
                        <button id="add-card-btn" class="bg-green-500 text-white font-bold py-3 rounded-lg hover:bg-green-600 transition shadow flex items-center justify-center gap-2"><i class="fa-solid fa-plus-circle"></i> Adicionar</button>
                        <button id="import-btn" class="bg-purple-500 text-white font-bold py-3 rounded-lg hover:bg-purple-600 transition shadow flex items-center justify-center gap-2"><i class="fa-solid fa-upload"></i> Importar</button>
                        <button id="export-btn" class="bg-indigo-500 text-white font-bold py-3 rounded-lg hover:bg-indigo-600 transition shadow flex items-center justify-center gap-2"><i class="fa-solid fa-download"></i> Exportar</button>
                        <button id="config-btn" class="bg-gray-500 text-white font-bold py-3 rounded-lg hover:bg-gray-600 transition shadow flex items-center justify-center gap-2"><i class="fa-solid fa-gear"></i> Configurar</button>
                    </div>
                </div>
            </div>

            <!-- Right Column -->
            <div class="lg:col-span-2">
                <div class="flex justify-end mb-4">
                    <div class="flex items-center gap-2">
                        <label for="sort-cards-by" class="font-medium text-gray-600">Ordenar cartelas por:</label>
                        <select id="sort-cards-by" class="border border-gray-300 rounded-lg p-2 focus:ring-2 focus:ring-blue-500">
                            <option value="marked">Mais marcadas</option>
                            <option value="alpha">Ordem alfabética</option>
                        </select>
                    </div>
                </div>
                <div id="cards-container" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
                    <!-- Cards will be injected here -->
                </div>
                 <div id="no-cards-message" class="hidden text-center bg-white p-10 rounded-xl shadow-md">
                    <i class="fa-solid fa-clone text-5xl text-gray-300 mb-4"></i>
                    <h3 class="text-xl font-bold text-gray-700">Nenhuma cartela registrada</h3>
                    <p class="text-gray-500 mt-2">Use o botão "Adicionar" para começar a gerenciar suas cartelas de bingo.</p>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer id="footer" class="text-center mt-8">
            <button id="delete-all-cards-btn" class="hidden bg-transparent border-2 border-red-500 text-red-500 font-bold py-3 px-6 rounded-lg hover:bg-red-500 hover:text-white transition shadow-sm">
                <i class="fa-solid fa-trash-alt"></i> Apagar todas as cartelas
            </button>
        </footer>
    </div>

    <!-- Modals Container -->
    <div id="modal-container"></div>

    <!-- Hidden file inputs -->
    <input type="file" id="import-file-input" class="hidden" accept=".json">
    <input type="file" id="camera-input" class="hidden" accept="image/*" capture="environment">

    <!-- JavaScript -->
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Gemini API Configuration ---
        // IMPORTANTE: Para habilitar o recurso da câmera, obtenha uma chave no Google AI Studio e cole-a aqui.
        const GEMINI_API_KEY = ""; 

        // --- Application State ---
        let state = {
            drawnNumbers: [],
            cards: [],
            settings: {
                winCondition: 'full', // 'full' or 'corners'
                sortDrawn: 'asc', // 'asc' or 'desc'
                sortCards: 'marked', // 'marked' or 'alpha'
            }
        };

        // --- Interaction State ---
        let lastCardTap = 0;
        let lastDrawnTap = 0;

        // --- DOM Elements ---
        const dom = {
            app: document.getElementById('app'),
            notificationContainer: document.getElementById('notification-container'),
            drawForm: document.getElementById('draw-form'),
            drawnNumberInput: document.getElementById('drawn-number-input'),
            drawnCount: document.getElementById('drawn-count'),
            drawnNumbersList: document.getElementById('drawn-numbers-list'),
            sortDrawnBtn: document.getElementById('sort-drawn-btn'),
            sortOrderText: document.getElementById('sort-order-text'),
            clearDrawnBtn: document.getElementById('clear-drawn-btn'),
            addCardBtn: document.getElementById('add-card-btn'),
            importBtn: document.getElementById('import-btn'),
            exportBtn: document.getElementById('export-btn'),
            configBtn: document.getElementById('config-btn'),
            sortCardsBy: document.getElementById('sort-cards-by'),
            cardsContainer: document.getElementById('cards-container'),
            noCardsMessage: document.getElementById('no-cards-message'),
            footer: document.getElementById('footer'),
            deleteAllCardsBtn: document.getElementById('delete-all-cards-btn'),
            modalContainer: document.getElementById('modal-container'),
            importFileInput: document.getElementById('import-file-input'),
            cameraInput: document.getElementById('camera-input'),
        };

        // --- Constants ---
        const BINGO_COLS = {
            'B': { min: 1, max: 15 },
            'I': { min: 16, max: 30 },
            'N': { min: 31, max: 45 },
            'G': { min: 46, max: 60 },
            'O': { min: 61, max: 75 },
        };
        const BINGO_LETTERS = ['B', 'I', 'N', 'G', 'O'];

        // --- State Management ---
        const saveState = () => {
            try {
                localStorage.setItem('bingoProState', JSON.stringify(state));
            } catch (error) {
                console.error("Erro ao salvar o estado:", error);
                showNotification("Erro ao salvar dados. O armazenamento pode estar cheio.", 'error');
            }
        };

        const loadState = () => {
            const savedState = localStorage.getItem('bingoProState');
            if (savedState) {
                try {
                    const parsedState = JSON.parse(savedState);
                    if (parsedState && typeof parsedState.cards !== 'undefined' && typeof parsedState.settings !== 'undefined') {
                        state = parsedState;
                    } else {
                        console.warn("Dados inválidos no localStorage. Iniciando do zero.");
                        saveState();
                    }
                } catch (error) {
                    console.error("Não foi possível analisar o estado do localStorage. Iniciando do zero.", error);
                    saveState();
                }
            } else {
                saveState();
            }
        };

        // --- Rendering ---
        const render = () => {
            renderDrawnNumbers();
            renderCards();
            updateControls();
        };

        const renderDrawnNumbers = () => {
            dom.drawnNumbersList.innerHTML = '';
            dom.drawnCount.textContent = state.drawnNumbers.length;

            const sortedNumbers = [...state.drawnNumbers].sort((a, b) => {
                return state.settings.sortDrawn === 'asc' ? a - b : b - a;
            });

            if (sortedNumbers.length === 0) {
                dom.drawnNumbersList.innerHTML = `<p class="text-center text-gray-500 text-sm">Nenhum número sorteado ainda.</p>`;
            } else {
                sortedNumbers.forEach(num => {
                    const letter = getBingoLetter(num);
                    const el = document.createElement('div');
                    el.className = 'bg-white shadow-sm rounded-full w-12 h-12 flex flex-col items-center justify-center font-bold text-gray-700 cursor-pointer hover:bg-red-100 transition';
                    el.innerHTML = `<div class="text-blue-600 text-xs">${letter}</div><div class="text-lg leading-tight">${num}</div>`;
                    el.dataset.number = num;
                    
                    el.addEventListener('dblclick', () => confirmRemoveDrawnNumber(num));
                    el.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        const currentTime = new Date().getTime();
                        const tapLength = currentTime - lastDrawnTap;
                        if (tapLength < 300 && tapLength > 0) {
                            confirmRemoveDrawnNumber(num);
                        }
                        lastDrawnTap = currentTime;
                    });
                    dom.drawnNumbersList.appendChild(el);
                });
            }
        };

        const renderCards = () => {
            dom.cardsContainer.innerHTML = '';
            
            const sortedCards = sortCards([...state.cards]);

            if (sortedCards.length === 0) {
                dom.noCardsMessage.classList.remove('hidden');
                dom.deleteAllCardsBtn.classList.add('hidden');
            } else {
                dom.noCardsMessage.classList.add('hidden');
                dom.deleteAllCardsBtn.classList.remove('hidden');
                sortedCards.forEach(card => {
                    const cardEl = createCardElement(card);
                    dom.cardsContainer.appendChild(cardEl);
                });
            }
        };
        
        const createCardElement = (card) => {
            const cardWrapper = document.createElement('div');
            cardWrapper.className = 'bg-white p-4 rounded-xl shadow-md relative overflow-hidden transition-all duration-300';
            
            const markedCount = countMarkedNumbers(card);
            const isWinner = checkWin(card);

            if (isWinner) {
                cardWrapper.classList.add('border-4', 'border-yellow-400', 'shadow-2xl');
                const banner = document.createElement('div');
                banner.className = 'winner-banner';
                banner.textContent = 'BINGO!';
                cardWrapper.appendChild(banner);
            }

            // NEW: Determine if the card has 24 or 25 numbers.
            const totalNumbers = card.grid.flat().includes('⭐️') ? 24 : 25;

            let cardHTML = `
                <div class="flex justify-between items-start mb-3">
                    <div>
                        <h3 class="text-xl font-bold truncate pr-16">${card.name}</h3>
                        <p class="text-sm text-gray-500">${markedCount} / ${totalNumbers} números marcados</p>
                    </div>
                    <div class="absolute top-4 right-4 flex space-x-2">
                        <button class="edit-card-btn text-gray-500 hover:text-blue-600" data-id="${card.id}"><i class="fas fa-pencil-alt"></i></button>
                        <button class="delete-card-btn text-gray-500 hover:text-red-600" data-id="${card.id}"><i class="fas fa-trash-alt"></i></button>
                    </div>
                </div>
                <div class="bingo-card-grid">
            `;

            BINGO_LETTERS.forEach(letter => {
                cardHTML += `
                    <div class="bingo-card-header bg-blue-500">
                        <span class="letter">${letter}</span>
                        <span class="range">${BINGO_COLS[letter].min}-${BINGO_COLS[letter].max}</span>
                    </div>
                `;
            });

            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 5; col++) {
                    const number = card.grid[col][row];
                    const isMarked = number === '⭐️' || state.drawnNumbers.includes(number);
                    const cellClass = isMarked ? 'marked' : 'bg-gray-100 hover:bg-gray-200';
                    cardHTML += `<div class="bingo-card-cell ${cellClass}" data-number="${number}" data-card-id="${card.id}">${number}</div>`;
                }
            }

            cardHTML += `</div>`;
            cardWrapper.innerHTML += cardHTML;
            return cardWrapper;
        };

        const updateControls = () => {
            dom.sortCardsBy.value = state.settings.sortCards;
            dom.sortOrderText.textContent = state.settings.sortDrawn === 'asc' ? 'Crescente' : 'Recente';
            
            if (state.cards.length === 0 && state.drawnNumbers.length === 0) {
                dom.exportBtn.disabled = true;
                dom.exportBtn.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                dom.exportBtn.disabled = false;
                dom.exportBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        };

        // --- Logic & Event Handlers ---
        const handleDrawFormSubmit = (e) => {
            e.preventDefault();
            const num = parseInt(dom.drawnNumberInput.value);
            if (!num || num < 1 || num > 75) {
                showNotification("Por favor, insira um número válido entre 1 e 75.", 'error');
                return;
            }
            if (state.drawnNumbers.includes(num)) {
                showNotification(`O número ${num} já foi sorteado.`, 'warning');
                dom.drawnNumberInput.value = '';
                dom.drawnNumberInput.focus();
                return;
            }
            addDrawnNumber(num);
            dom.drawnNumberInput.value = '';
            dom.drawnNumberInput.focus();
        };

        const addDrawnNumber = (num, showMsg = true) => {
            if (!state.drawnNumbers.includes(num)) {
                state.drawnNumbers.push(num);
                saveState();
                render();
                if (showMsg) {
                    showNotification(`Número ${num} adicionado!`, 'success');
                }
            }
        };

        const removeDrawnNumber = (num) => {
            state.drawnNumbers = state.drawnNumbers.filter(n => n !== num);
            saveState();
            render();
            showNotification(`Número ${num} removido.`, 'warning');
        };

        const confirmRemoveDrawnNumber = (num) => {
            showConfirmationModal(
                `Remover número`,
                `Tem certeza de que deseja remover o número ${num} da lista de sorteados? Isso desmarcará o número em todas as cartelas.`,
                () => removeDrawnNumber(num)
            );
        };

        const handleCardNumberDoubleClick = (e) => {
            const target = e.target.closest('.bingo-card-cell');
            if (!target) return;

            const numberStr = target.dataset.number;
            if (numberStr === '⭐️' || numberStr === 'null') return;
            
            const number = parseInt(numberStr);

            if (state.drawnNumbers.includes(number)) {
                confirmRemoveDrawnNumber(number);
            } else {
                addDrawnNumber(number, true);
            }
        };

        const handleClearDrawn = () => {
            if (state.drawnNumbers.length === 0) return;
            showConfirmationModal(
                'Limpar sorteio',
                'Tem certeza de que deseja limpar todos os números sorteados? Esta ação não pode ser desfeita.',
                () => {
                    state.drawnNumbers = [];
                    saveState();
                    render();
                    showNotification('Sorteio limpo com sucesso!', 'warning');
                }
            );
        };

        const handleSortDrawn = () => {
            state.settings.sortDrawn = state.settings.sortDrawn === 'asc' ? 'desc' : 'asc';
            saveState();
            render();
        };
        
        const handleSortCards = (e) => {
            state.settings.sortCards = e.target.value;
            saveState();
            renderCards();
        };

        const handleAddCard = () => {
            showAddCardChoiceModal();
        };

        const handleEditCard = (cardId) => {
            const card = state.cards.find(c => c.id === cardId);
            if (card) {
                showCardFormModal(card);
            }
        };

        const handleDeleteCard = (cardId) => {
            const card = state.cards.find(c => c.id === cardId);
            if (!card) return;
            showConfirmationModal(
                'Apagar cartela',
                `Tem certeza de que deseja apagar a cartela "${card.name}"? Esta ação não pode ser desfeita.`,
                () => {
                    state.cards = state.cards.filter(c => c.id !== cardId);
                    saveState();
                    render();
                    showNotification(`Cartela "${card.name}" apagada.`, 'warning');
                }
            );
        };

        const handleDeleteAllCards = () => {
            showConfirmationModal(
                'Apagar todas as cartelas',
                'Tem certeza de que deseja apagar TODAS as cartelas? Esta ação é irreversível.',
                () => {
                    state.cards = [];
                    saveState();
                    render();
                    showNotification('Todas as cartelas foram apagadas.', 'warning');
                }
            );
        };
        
        const handleConfig = () => {
            showConfigModal();
        };

        const handleExport = () => {
            if (dom.exportBtn.disabled) return;
            showExportModal();
        };

        const handleImport = () => {
            dom.importFileInput.click();
        };

        const handleImportFile = (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const importedData = JSON.parse(event.target.result);
                    if (!importedData.cards || !importedData.drawnNumbers || !importedData.settings) {
                        throw new Error("Formato de arquivo inválido.");
                    }
                    
                    showConfirmationModal(
                        'Importar dados',
                        `Você está prestes a importar ${importedData.cards.length} cartela(s) e ${importedData.drawnNumbers.length} número(s) sorteado(s). Os dados atuais serão mesclados. Deseja continuar?`,
                        () => {
                            const existingCardIds = new Set(state.cards.map(c => c.id));
                            const newCards = importedData.cards.filter(c => !existingCardIds.has(c.id));
                            state.cards.push(...newCards);
                            
                            const existingDrawn = new Set(state.drawnNumbers);
                            const newDrawn = importedData.drawnNumbers.filter(n => !existingDrawn.has(n));
                            state.drawnNumbers.push(...newDrawn);

                            state.settings = importedData.settings;

                            saveState();
                            render();
                            showNotification('Dados importados com sucesso!', 'success');
                        }
                    );
                } catch (error) {
                    console.error("Erro ao importar arquivo:", error);
                    showNotification("Erro ao ler o arquivo. Verifique se é um JSON válido do Bingo Pro.", "error");
                } finally {
                    e.target.value = null;
                }
            };
            reader.readAsText(file);
        };
        
        const handleCameraFileSelect = (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const base64Image = event.target.result.split(',')[1];
                processImageWithGemini(base64Image);
            };
            reader.readAsDataURL(file);
            e.target.value = null;
        };

        // --- Modal Functions ---
        const closeModal = () => {
            dom.modalContainer.innerHTML = '';
        };

        const showModal = (content) => {
            const modalBackdrop = document.createElement('div');
            modalBackdrop.className = 'modal-backdrop';
            modalBackdrop.addEventListener('click', (e) => {
                if (e.target === modalBackdrop) {
                    closeModal();
                }
            });

            const modalContent = document.createElement('div');
            modalContent.className = 'modal-content';
            modalContent.innerHTML = content;

            modalBackdrop.appendChild(modalContent);
            dom.modalContainer.appendChild(modalBackdrop);
            return modalContent;
        };
        
        const showConfirmationModal = (title, message, onConfirm) => {
            const content = `
                <h3 class="text-xl font-bold mb-4">${title}</h3>
                <p class="mb-6">${message}</p>
                <div class="flex justify-end gap-3">
                    <button id="modal-cancel-btn" class="bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300">Cancelar</button>
                    <button id="modal-confirm-btn" class="bg-red-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600">Confirmar</button>
                </div>
            `;
            const modal = showModal(content);
            modal.querySelector('#modal-cancel-btn').addEventListener('click', closeModal);
            modal.querySelector('#modal-confirm-btn').addEventListener('click', () => {
                onConfirm();
                closeModal();
            });
        };

        const showAddCardChoiceModal = () => {
            const content = `
                <h3 class="text-xl font-bold mb-4">Adicionar nova cartela</h3>
                <p class="mb-6">Como você gostaria de adicionar a cartela?</p>
                <div class="flex flex-col gap-4">
                    <button id="manual-add-btn" class="w-full bg-blue-500 text-white font-bold py-3 rounded-lg hover:bg-blue-600 transition flex items-center justify-center gap-2"><i class="fa-solid fa-keyboard"></i> Preenchimento manual</button>
                    <button id="camera-add-btn" class="w-full bg-teal-500 text-white font-bold py-3 rounded-lg hover:bg-teal-600 transition flex items-center justify-center gap-2"><i class="fa-solid fa-camera"></i> Usar a câmera</button>
                </div>
                 <div class="mt-6 flex justify-end">
                    <button id="modal-cancel-btn" class="bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300">Cancelar</button>
                </div>
            `;
            const modal = showModal(content);
            modal.querySelector('#manual-add-btn').addEventListener('click', () => {
                closeModal();
                showCardFormModal();
            });
            modal.querySelector('#camera-add-btn').addEventListener('click', () => {
                if (!GEMINI_API_KEY) {
                    showNotification("Função indisponível: a chave da API do Gemini não foi configurada.", "error");
                    return;
                }
                closeModal();
                dom.cameraInput.click();
            });
            modal.querySelector('#modal-cancel-btn').addEventListener('click', closeModal);
        };

        const showCardFormModal = (cardToEdit = null) => {
            const isEditing = cardToEdit !== null;
            const title = isEditing ? 'Editar cartela' : 'Nova cartela';
            
            let gridInputs = '';
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 5; col++) {
                    const value = isEditing && cardToEdit.grid[col] && cardToEdit.grid[col][row] ? (cardToEdit.grid[col][row] === '⭐️' ? '' : cardToEdit.grid[col][row]) : '';
                    const dataAttrs = `data-col="${col}" data-row="${row}"`;
                    gridInputs += `<input type="number" min="1" max="75" placeholder="" value="${value}" ${dataAttrs} class="card-grid-input w-full aspect-square text-center border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500">`;
                }
            }

            const modalHeaders = BINGO_LETTERS.map(letter => `
                <div class="bingo-card-header bg-blue-500">
                    <span class="letter">${letter}</span>
                    <span class="range">${BINGO_COLS[letter].min}-${BINGO_COLS[letter].max}</span>
                </div>
            `).join('');

            const content = `
                <form id="card-form">
                    <h3 class="text-xl font-bold mb-4 flex justify-between items-center">${title} <i class="fa-solid fa-camera text-gray-400 hover:text-blue-500 cursor-pointer" id="form-camera-btn"></i></h3>
                    <div class="mb-4">
                        <label for="card-name" class="block font-medium mb-1">Nome da cartela</label>
                        <input type="text" id="card-name" required value="${isEditing ? cardToEdit.name : ''}" placeholder="Ex: Cartela da Sorte" class="w-full p-2 border border-gray-300 rounded-lg">
                    </div>
                    <div class="bingo-card-grid mb-4">
                        ${modalHeaders}
                        ${gridInputs}
                    </div>
                    <div class="flex justify-end gap-3">
                        <button type="button" id="modal-cancel-btn" class="bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300">Cancelar</button>
                        <button type="submit" class="bg-green-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-green-600">Salvar</button>
                    </div>
                </form>
            `;
            const modal = showModal(content);
            const form = modal.querySelector('#card-form');
            const inputs = Array.from(modal.querySelectorAll('.card-grid-input'));
            const cardNameInput = modal.querySelector('#card-name');
            const saveButton = form.querySelector('button[type="submit"]');
            
            cardNameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || (e.key === 'Tab' && !e.shiftKey)) {
                    e.preventDefault();
                    inputs.find(i => parseInt(i.dataset.col) === 0 && parseInt(i.dataset.row) === 0)?.focus();
                }
            });

            inputs.forEach((input) => {
                input.addEventListener('keydown', (e) => {
                    const col = parseInt(input.dataset.col);
                    const row = parseInt(input.dataset.row);

                    if (e.key === 'Enter' || (e.key === 'Tab' && !e.shiftKey)) {
                        e.preventDefault();
                        if (row < 4) {
                            inputs.find(i => parseInt(i.dataset.col) === col && parseInt(i.dataset.row) === row + 1)?.focus();
                        } else if (col < 4) {
                            inputs.find(i => parseInt(i.dataset.col) === col + 1 && parseInt(i.dataset.row) === 0)?.focus();
                        } else {
                            saveButton.focus();
                        }
                    } else if (e.key === 'Tab' && e.shiftKey) {
                        e.preventDefault();
                        if (row > 0) {
                            inputs.find(i => parseInt(i.dataset.col) === col && parseInt(i.dataset.row) === row - 1)?.focus();
                        } else if (col > 0) {
                            inputs.find(i => parseInt(i.dataset.col) === col - 1 && parseInt(i.dataset.row) === 4)?.focus();
                        } else {
                            cardNameInput.focus();
                        }
                    }
                });
            });
            
            saveButton.addEventListener('keydown', (e) => {
                if (e.key === 'Tab' && e.shiftKey) {
                    e.preventDefault();
                    inputs.find(i => parseInt(i.dataset.col) === 4 && parseInt(i.dataset.row) === 4)?.focus();
                }
            });

            form.addEventListener('submit', (e) => {
                e.preventDefault();
                const name = cardNameInput.value.trim();
                if (!name) {
                    showNotification("O nome da cartela é obrigatório.", "error");
                    return;
                }

                const grid = [[], [], [], [], []];
                const allNumbers = new Set();
                let hasValidationError = false;
                
                inputs.forEach(input => input.classList.remove('border-red-500'));

                inputs.forEach(input => {
                    if (hasValidationError) return;

                    const col = parseInt(input.dataset.col);
                    const row = parseInt(input.dataset.row);
                    const isCenter = col === 2 && row === 2;
                    let value = input.value.trim();

                    if (isCenter && value === '') {
                        grid[col][row] = '⭐️';
                        return;
                    }
                    
                    if (!value) {
                        hasValidationError = true;
                        input.classList.add('border-red-500');
                        return;
                    }
                    
                    const num = parseInt(value);
                    if (isNaN(num)) {
                        hasValidationError = true;
                        input.classList.add('border-red-500');
                        return;
                    }

                    const letter = BINGO_LETTERS[col];
                    const range = BINGO_COLS[letter];
                    if (num < range.min || num > range.max) {
                        hasValidationError = true;
                        input.classList.add('border-red-500');
                        showNotification(`Número ${num} na coluna ${letter} está fora do intervalo (${range.min}-${range.max}).`, 'error');
                        return;
                    }

                    if (allNumbers.has(num)) {
                        hasValidationError = true;
                        input.classList.add('border-red-500');
                        showNotification(`Número duplicado: ${num}.`, 'error');
                        return;
                    }
                    
                    allNumbers.add(num);
                    grid[col][row] = num;
                });

                const hasFreeSpace = grid.flat().includes('⭐️');
                const requiredNumbers = hasFreeSpace ? 24 : 25;

                if (hasValidationError || allNumbers.size < requiredNumbers) {
                    if (!hasValidationError) {
                         showNotification(`Preencha todos os ${requiredNumbers} campos da cartela.`, "error");
                    }
                    return;
                }

                if (isEditing) {
                    const cardIndex = state.cards.findIndex(c => c.id === cardToEdit.id);
                    state.cards[cardIndex] = { ...cardToEdit, name, grid };
                    showNotification("Cartela atualizada com sucesso!", "success");
                } else {
                    state.cards.push({ id: Date.now(), name, grid });
                    showNotification("Cartela salva com sucesso!", "success");
                }
                
                saveState();
                render();
                closeModal();
            });

            modal.querySelector('#modal-cancel-btn').addEventListener('click', closeModal);
            modal.querySelector('#form-camera-btn').addEventListener('click', () => {
                if (!GEMINI_API_KEY) {
                    showNotification("Função indisponível: a chave da API do Gemini não foi configurada.", "error");
                    return;
                }
                closeModal();
                dom.cameraInput.click();
            });
        };
        
        const showConfigModal = () => {
            const content = `
                <h3 class="text-xl font-bold mb-4">Configurações de vitória</h3>
                <p class="mb-4 text-gray-600">Escolha a condição para um "BINGO!".</p>
                <div class="space-y-3">
                    <label class="flex items-center p-3 border rounded-lg cursor-pointer hover:bg-gray-50">
                        <input type="radio" name="win-condition" value="full" class="h-5 w-5 text-blue-600 focus:ring-blue-500" ${state.settings.winCondition === 'full' ? 'checked' : ''}>
                        <span class="ml-3 text-gray-700 font-medium">Cheia (marcar todos os números)</span>
                    </label>
                    <label class="flex items-center p-3 border rounded-lg cursor-pointer hover:bg-gray-50">
                        <input type="radio" name="win-condition" value="corners" class="h-5 w-5 text-blue-600 focus:ring-blue-500" ${state.settings.winCondition === 'corners' ? 'checked' : ''}>
                        <span class="ml-3 text-gray-700 font-medium">Quinas (linhas, colunas, diagonais)</span>
                    </label>
                </div>
                <div class="flex justify-end gap-3 mt-6">
                    <button id="modal-cancel-btn" class="bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300">Cancelar</button>
                    <button id="modal-save-btn" class="bg-blue-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-600">Salvar</button>
                </div>
            `;
            const modal = showModal(content);
            modal.querySelector('#modal-cancel-btn').addEventListener('click', closeModal);
            modal.querySelector('#modal-save-btn').addEventListener('click', () => {
                const selected = modal.querySelector('input[name="win-condition"]:checked').value;
                state.settings.winCondition = selected;
                saveState();
                render();
                closeModal();
                showNotification("Configurações salvas!", "info");
            });
        };
        
        const showExportModal = () => {
            const defaultName = `bingo-pro_backup_${new Date().toISOString().slice(0,10)}.json`;
            const content = `
                <h3 class="text-xl font-bold mb-4">Exportar dados</h3>
                <p class="mb-4">Seus dados (cartelas e números sorteados) serão salvos em um arquivo JSON. Guarde-o em um local seguro.</p>
                <div class="mb-4">
                    <label for="export-filename" class="block font-medium mb-1">Nome do arquivo</label>
                    <input type="text" id="export-filename" value="${defaultName}" class="w-full p-2 border border-gray-300 rounded-lg">
                </div>
                <div class="flex justify-end gap-3">
                    <button id="modal-cancel-btn" class="bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300">Cancelar</button>
                    <button id="modal-export-btn" class="bg-indigo-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-indigo-600">Exportar</button>
                </div>
            `;
            const modal = showModal(content);
            modal.querySelector('#modal-cancel-btn').addEventListener('click', closeModal);
            modal.querySelector('#modal-export-btn').addEventListener('click', () => {
                const filename = modal.querySelector('#export-filename').value || defaultName;
                const dataStr = JSON.stringify(state, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                closeModal();
                showNotification("Dados exportados com sucesso!", "success");
            });
        };

        const showProcessingModal = () => {
            const content = `
                <div id="gemini-processing-modal" class="text-center">
                    <div class="w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full animate-spin-slow mx-auto mb-6"></div>
                    <h3 class="text-xl font-bold mb-2">Processando...</h3>
                    <p class="text-gray-600 mb-6">Aguarde enquanto a imagem é processada pelo Gemini. Lembre-se de conferir os valores antes de cadastrar a cartela.</p>
                    <button id="modal-cancel-btn" class="bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300">Cancelar</button>
                </div>
            `;
            const modal = showModal(content);
            modal.querySelector('#modal-cancel-btn').addEventListener('click', () => {
                closeModal();
            });
        };

        // --- Helper Functions ---
        const getBingoLetter = (number) => {
            for (const letter in BINGO_COLS) {
                if (number >= BINGO_COLS[letter].min && number <= BINGO_COLS[letter].max) {
                    return letter;
                }
            }
            return '?';
        };

        const countMarkedNumbers = (card) => {
            let count = 0;
            card.grid.flat().forEach(num => {
                if (num !== '⭐️' && state.drawnNumbers.includes(num)) {
                    count++;
                }
            });
            return count;
        };

        const sortCards = (cards) => {
            return cards.sort((a, b) => {
                if (state.settings.sortCards === 'alpha') {
                    return a.name.localeCompare(b.name);
                } else { // 'marked'
                    const markedA = countMarkedNumbers(a);
                    const markedB = countMarkedNumbers(b);
                    return markedB - markedA;
                }
            });
        };

        const checkWin = (card) => {
            const isMarked = (row, col) => {
                const val = card.grid[col][row];
                return val === '⭐️' || state.drawnNumbers.includes(val);
            };

            const checkLine = (line) => line.every(cell => isMarked(cell.row, cell.col));

            const lines = [];
            for (let i = 0; i < 5; i++) {
                const row = [];
                const col = [];
                for (let j = 0; j < 5; j++) {
                    row.push({ row: i, col: j });
                    col.push({ row: j, col: i });
                }
                lines.push(row, col);
            }
            const diag1 = [];
            const diag2 = [];
            for (let i = 0; i < 5; i++) {
                diag1.push({ row: i, col: i });
                diag2.push({ row: i, col: 4 - i });
            }
            lines.push(diag1, diag2);

            if (state.settings.winCondition === 'corners') {
                return lines.some(line => checkLine(line));
            } else { // 'full'
                for (let i = 0; i < 5; i++) {
                    for (let j = 0; j < 5; j++) {
                        if (!isMarked(i, j)) return false;
                    }
                }
                return true;
            }
        };

        const showNotification = (message, type = 'info') => {
            const notification = document.createElement('div');
            let bgColor, iconClass;
            switch (type) {
                case 'success': bgColor = 'bg-green-500'; iconClass = 'fa-check-circle'; break;
                case 'error': bgColor = 'bg-red-500'; iconClass = 'fa-times-circle'; break;
                case 'warning': bgColor = 'bg-orange-500'; iconClass = 'fa-exclamation-triangle'; break;
                default: bgColor = 'bg-blue-500'; iconClass = 'fa-info-circle'; break;
            }
            
            notification.className = `pointer-events-auto max-w-sm w-full ${bgColor} text-white py-3 px-5 rounded-lg shadow-xl transform -translate-y-20 opacity-0 transition-all duration-500 ease-in-out flex items-center gap-3`;
            notification.innerHTML = `<i class="fa-solid ${iconClass}"></i><span>${message}</span>`;
            
            dom.notificationContainer.appendChild(notification);

            requestAnimationFrame(() => {
                notification.classList.remove('-translate-y-20', 'opacity-0');
            });

            setTimeout(() => {
                notification.classList.add('-translate-y-20', 'opacity-0');
                notification.addEventListener('transitionend', () => notification.remove());
            }, 3000);
        };

        // --- Gemini API Integration ---
        const processImageWithGemini = async (base64ImageData) => {
            showProcessingModal();
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;
            const prompt = `Analise a imagem desta cartela de bingo. Sua tarefa é extrair todos os números e sua posição exata na grade 5x5. Retorne um objeto JSON bem-formado com uma única chave chamada "grid". O valor de "grid" deve ser um array de 5 arrays (representando as 5 linhas da cartela, de cima para baixo). Cada um desses 5 arrays deve conter 5 elementos (representando as 5 colunas, da esquerda para a direita). Os elementos devem ser os números inteiros lidos da cartela. Se uma célula estiver vazia, for o espaço livre central, ou se um número não puder ser lido com clareza naquela posição, use o valor null. Não inclua nenhum texto explicativo, comentários ou markdown na sua resposta. Apenas o objeto JSON. Exemplo do formato de resposta esperado: {"grid": [[1,16,31,46,61],[2,17,32,47,62],[3,18,null,48,63],[4,19,34,49,64],[5,20,35,50,65]]}`;

            const payload = {
                contents: [{
                    parts: [
                        { text: prompt },
                        { inline_data: { mime_type: "image/jpeg", data: base64ImageData } }
                    ]
                }]
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Erro da API Gemini:", errorData);
                    throw new Error(`Erro na API: ${errorData.error?.message || response.statusText}`);
                }

                const result = await response.json();
                const textResponse = result.candidates[0].content.parts[0].text;
                
                const jsonString = textResponse.match(/{[\s\S]*}/)[0];
                const parsedJson = JSON.parse(jsonString);

                if (!parsedJson.grid || parsedJson.grid.length !== 5) {
                    throw new Error("Resposta da API em formato inesperado.");
                }

                const transposedGrid = parsedJson.grid[0].map((_, colIndex) => parsedJson.grid.map(row => row[colIndex]));

                const cardData = {
                    id: null,
                    name: `Cartela da câmera ${new Date().toLocaleTimeString()}`,
                    grid: transposedGrid.map(col => col.map(cell => cell === null ? '' : cell))
                };
                
                closeModal();
                showCardFormModal(cardData);

            } catch (error) {
                console.error("Falha ao processar imagem:", error);
                closeModal();
                showNotification("Não foi possível ler a cartela. Tente uma foto mais nítida.", "error");
            }
        };

        // --- PWA Manifest Generation ---
        const generateIcon = (size) => {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#3b82f6';
            ctx.beginPath();
            ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'white';
            ctx.font = `bold ${size * 0.6}px Inter, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('B', size / 2, size / 2 + size * 0.04);

            return canvas.toDataURL('image/png');
        };

        const setupPWA = () => {
            const manifest = {
                "name": "Bingo Pro",
                "short_name": "Bingo Pro",
                "start_url": ".",
                "display": "standalone",
                "background_color": "#f0f2f5",
                "theme_color": "#3b82f6",
                "description": "Seu gestor de cartelas de bingo que funciona offline.",
                "icons": [
                    { "src": generateIcon(192), "sizes": "192x192", "type": "image/png" },
                    { "src": generateIcon(512), "sizes": "512x512", "type": "image/png" }
                ]
            };
            const manifestBlob = new Blob([JSON.stringify(manifest)], {type: 'application/json'});
            const manifestURL = URL.createObjectURL(manifestBlob);
            
            const link = document.createElement('link');
            link.rel = 'manifest';
            link.href = manifestURL;
            document.head.appendChild(link);
        };

        // --- Initialization ---
        const init = () => {
            dom.drawForm.addEventListener('submit', handleDrawFormSubmit);
            dom.clearDrawnBtn.addEventListener('click', handleClearDrawn);
            dom.sortDrawnBtn.addEventListener('click', handleSortDrawn);
            dom.addCardBtn.addEventListener('click', handleAddCard);
            dom.configBtn.addEventListener('click', handleConfig);
            dom.exportBtn.addEventListener('click', handleExport);
            dom.importBtn.addEventListener('click', handleImport);
            dom.importFileInput.addEventListener('change', handleImportFile);
            dom.cameraInput.addEventListener('change', handleCameraFileSelect);
            dom.deleteAllCardsBtn.addEventListener('click', handleDeleteAllCards);
            dom.sortCardsBy.addEventListener('change', handleSortCards);

            dom.cardsContainer.addEventListener('click', (e) => {
                if (e.target.closest('.delete-card-btn')) {
                    const id = parseInt(e.target.closest('.delete-card-btn').dataset.id);
                    handleDeleteCard(id);
                } else if (e.target.closest('.edit-card-btn')) {
                    const id = parseInt(e.target.closest('.edit-card-btn').dataset.id);
                    handleEditCard(id);
                }
            });
            
            dom.cardsContainer.addEventListener('touchend', (e) => {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastCardTap;
                if (tapLength < 300 && tapLength > 0) {
                    e.preventDefault();
                    handleCardNumberDoubleClick(e);
                }
                lastCardTap = currentTime;
            });
            dom.cardsContainer.addEventListener('dblclick', handleCardNumberDoubleClick);

            loadState();
            setupPWA();
            render();
        };

        init();
    });
    </script>
</body>
</html>
